import numpy as np
import openalea.plantgl.all as pgl
from openalea.lpy import *

from vmlab.enums import Position

phyllotaxy = 144.
branching_angle = 60.

module GU(idx)
module A(idx)


Axiom:
    nproduce @Tp(0, 0, 1) @Ts(0.02)
    nproduce SectionResolution(6)
    nproduce @Gc
    nproduce GU(0) A(0)


derivation length: derivation_length
ignore: / &

production:

A(idx):
    # grow index by nb_children
    if process.bursted[idx] == 1.:
        nb_lateral_children = process.archdev[('arch_dev', 'nb_lateral_children')]
        has_apical_child = process.archdev[('arch_dev', 'has_apical_child')]
        nature = process.archdev[('arch_dev', 'nature')]
        # idx of first child
        idx_first_child = process.GU.shape[0]
        nb_children = int(nb_lateral_children[idx] + has_apical_child[idx])
        process.GU = np.append(process.GU, [f'GU{i + process.GU.shape[0]}' for i in range(nb_children)])
        step_date = process.step_start.astype('datetime64[D]')
        # initialize new GUs
        process.appearance_month[idx_first_child:] = step_date.item().month
        process.appearance_date[idx_first_child:] = step_date
        process.appeared[idx_first_child:] = 1.
        process.adjacency[np.isnan(process.adjacency)] = 0.
        process.cycle[idx_first_child:] = process.current_cycle
        # set child idx_first_child process variable values and produce
        for i_child in range(nb_children):
            idx_child = idx_first_child + i_child
            if i_child == nb_children - 1 and has_apical_child[idx]:
                process.position[idx_child] = Position.APICAL
                nsproduce([GU(idx_child), A(idx_child)])
            else:
                process.position[idx_child] = Position.LATERAL
                nsproduce([RollL(phyllotaxy), SB(), Down(branching_angle), GU(idx_child), A(idx_child), EB()])
            if process.current_cycle != process.cycle[idx]:
                process.ancestor[idx_child] = idx
                process.ancestor_is_apical[idx_child] = process.position[idx]
                process.ancestor_nature[idx_child] = nature[idx]
            else:
                process.ancestor[idx_child] = process.ancestor[idx]
                process.ancestor_is_apical[idx_child] = process.ancestor_is_apical[idx]
                process.ancestor_nature[idx_child] = process.ancestor_nature[idx]
            process.adjacency[idx, idx_child] = 1.
            process.position_parent[idx_child] = process.position[idx]
    else:
        for idx_child in np.flatnonzero(process.adjacency[idx, :]):
            if process.position[idx_child] == Position.APICAL:
                nsproduce([GU(idx_child), A(idx_child)])
            else:
                nsproduce([RollL(phyllotaxy), SB(), Down(branching_angle), GU(idx_child), A(idx_child), EB()])


interpretation:
maximum depth: 10


GU(idx):
    radius_gu = process.growth[('growth', 'radius_gu')][idx]
    final_length_internodes = process.growth[('growth', 'final_length_internodes')][idx]
    length_gu = process.growth[('growth', 'length_gu')][idx]
    final_length_gu = process.growth[('growth', 'final_length_gu')][idx]
    if length_gu > 1e-3:
        gu_growth_ratio = length_gu / final_length_gu
        nsproduce([EndGC(), StartGC()])
        nsproduce([SetWidth(radius_gu)])
        for final_length_internode in final_length_internodes:
            nsproduce([F(final_length_internode * gu_growth_ratio, radius_gu), RollL(phyllotaxy)])
        nsproduce([Sphere(radius_gu)])

endlsystem
